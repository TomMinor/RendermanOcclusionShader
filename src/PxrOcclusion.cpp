/* 
 PxrOcclusion.cpp
 Generated by Cutter from:
     "/transfer/pixelbusters_work/pipeline/plugins/Args/PxrOcclusion.args"
 at 5.58:18pm 8.7.2016
*/
#include <RixPattern.h> 
#include <RixShadingUtils.h>
#include <RixShading.h>
#include <RixInterfaces.h>
#include <cstring>
#include <RixIntegrator.h>

//#include <cstdio>
//#include <sstream>
#include <cmath>

float clamp(float n, float lower, float upper) {
  return std::max(lower, std::min(n, upper));
}

float mix(float x, float y, float a)
{
	return (y * a) + x * (1.0 - a);
}

class PxrOcclusion : public RixPattern {
public:

    PxrOcclusion();
    virtual ~PxrOcclusion() { }
    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable();
    virtual void Finalize(RixContext &) { }
    virtual int ComputeOutputParams(RixShadingContext const *ctx,
                                    RtInt *noutputs, 
                                    OutputSpec **outputs,
                                    RtConstPointer instanceData,
                                    RixSCParamInfo const *ignored);
	private:
		RixMessages *m_msg;
		RixShadeFunctions *m_shd;  // Shading functions in RixInterfaces.h
		RixShadingContext* m_shading;
		RtInt		m_int_samples;
		RtFloat		m_float_maxdist;
		RtFloat		m_float_distscale;
		RtColorRGB	m_rgb_primary;
		RtColorRGB	m_rgb_secondary;

		
		void getTraceBias(RixShadingContext const &sctx, RtInt &autoBias, RtFloat &biasValue);
	};

PxrOcclusion::PxrOcclusion():
	m_msg(NULL),
	m_shd(NULL),
	m_int_samples(20),
	m_float_maxdist(0.1),
	m_float_distscale(0.01),
	m_rgb_primary(1,1,1),
	m_rgb_secondary(0,0,0)
	{ }

int PxrOcclusion::Init(RixContext &ctx, char const *pluginpath) {
    m_msg = (RixMessages*)ctx.GetRixInterface(k_RixMessages);
    m_shd = (RixShadeFunctions*)ctx.GetRixInterface(k_RixShadeFunctions);

    // Uncomment the next three lines if a rib Option will be queried.
    //RixRenderState *rstate = (RixRenderState*)ctx.GetRixInterface(k_RixRenderState);
    //RixRenderState::Type optType;
    //RtInt optNumValues, err;
    // Example of using messaging,
    //    m_msg->Info("%f\n", a_float_value);
    return (!m_msg) ? 1 : 0;
    }

RixSCParamInfo const *PxrOcclusion::GetParamTable() {
    static RixSCParamInfo s_ptable[] = {
		// Output
		RixSCParamInfo("result", k_RixSCColor, k_RixSCOutput),
		RixSCParamInfo("resultF", k_RixSCFloat, k_RixSCOutput),
		// Input
		RixSCParamInfo("int_samples", k_RixSCInteger),
		RixSCParamInfo("float_maxdist", k_RixSCFloat),
		RixSCParamInfo("float_distscale", k_RixSCFloat),
		RixSCParamInfo("rgb_primary", k_RixSCColor),
		RixSCParamInfo("rgb_secondary", k_RixSCColor),
		RixSCParamInfo("str_traceset", k_RixSCString),
		RixSCParamInfo() // end of table
        };
    return &s_ptable[0];
    }

enum paramIndex {
	k_result = 0,
	k_resultF,
	k_int_samples,
	k_float_maxdist,
	k_float_distscale,	
	k_rgb_primary,
	k_rgb_secondary,
	k_str_traceset
    };

void
PxrOcclusion::getTraceBias(RixShadingContext const &sctx,
                           RtInt &autoBias, RtFloat &biasValue)
{
    static const int      k_autoBiasLen   = sizeof(RtInt);
    static const int      k_biasLen       = sizeof(RtFloat);

    // set to defaults
    autoBias     = 1;
    biasValue    = 0.01f;

    if (RixRenderState *state =
                (RixRenderState *) sctx.GetRixInterface(k_RixRenderState))
    {
        RixRenderState::Type autoBiasType, biasType;
        RtFloat autoBiasVal, biasVal;
        RtInt autoBiasRet, biasRet;
        RtInt autoBiasCount, biasCount;

        autoBiasRet = state->GetAttribute("trace:autobias", &autoBiasVal,
                                          k_autoBiasLen,  &autoBiasType,
                                          &autoBiasCount);

        if (autoBiasRet == 0 && autoBiasCount == 1)
            autoBias = (RtInt) autoBiasVal;

        if (autoBias > 0)
        {
            biasRet = state->GetAttribute("trace:bias", &biasVal,
                                          k_biasLen,  &biasType, &biasCount);

            if (biasRet == 0 && biasCount == 1)
                biasValue = biasVal;            
        }
    }
}
	
int PxrOcclusion::ComputeOutputParams(RixShadingContext const *ctx,
								RtInt *noutputs, 
								OutputSpec **outputs,
								RtConstPointer instanceData,
								RixSCParamInfo const *ignored) {

	// Uncomment the next three lines if a rib Attribute will be queried. Note
	// that Rib Options should be queried in the init() method - not here!
	//RixRenderState *rstate = (RixRenderState*)ctx->GetRixInterface(k_RixRenderState);
	//RixRenderState::Type attrType;
	//RtInt attrNumValues, err;

	// OUTPUTS BEGIN____________________________________
	// Allocate memory for the OutputSpec data structure.
	RixShadingContext::Allocator pool(ctx);
	OutputSpec *outSpec = pool.AllocForPattern<OutputSpec>(1);
	*outputs = outSpec;

	// Allocate memory for each output.
	RtColorRGB	*result = pool.AllocForPattern<RtColorRGB>(ctx->numPts);
	RtFloat	*resultF = pool.AllocForPattern<RtFloat>(ctx->numPts);


	// Connect the output(s) to the OutputSpec.
	*noutputs = 2;
	outSpec[0].paramId = k_result;
	outSpec[0].detail = k_RixSCVarying;
	outSpec[0].value = result;
	outSpec[1].paramId = k_resultF;
	outSpec[1].detail = k_RixSCVarying;
	outSpec[1].value = resultF;

	// INPUTS BEGIN____________________________________
	bool varying = true;
	bool uniform = false;
	// Declare a pointer for each input then obtain their values
	// using EvalParam().
	RtInt		const *int_samples;
	RtFloat		const *float_maxdist;
	RtFloat		const *float_distscale;	
	RtColorRGB	const *rgb_primary;
	RtColorRGB	const *rgb_secondary;
	RtConstString	 *str_traceset;
	ctx->EvalParam(k_int_samples, -1, &int_samples, &m_int_samples, varying);
	ctx->EvalParam(k_float_maxdist, -1, &float_maxdist, &m_float_maxdist, varying);
	ctx->EvalParam(k_float_distscale, -1, &float_distscale, &m_float_distscale, varying);	
	ctx->EvalParam(k_rgb_primary, -1, &rgb_primary, &m_rgb_primary, varying);
	ctx->EvalParam(k_rgb_secondary, -1, &rgb_secondary, &m_rgb_secondary, varying);
	ctx->EvalParam(k_str_traceset, -1, &str_traceset);


	// Assign an array of surface positions to P.
	RtPoint3 const  *P;
	ctx->GetBuiltinVar(RixShadingContext::k_P, &P);

	// Copy the original P data to the transP array.
	RtPoint3 *transP = pool.AllocForPattern<RtPoint3>(ctx->numPts);
	memcpy(transP, P, sizeof(RtPoint3) * ctx->numPts);

	// Transform will over-write the original transP data.
	ctx->Transform(RixShadingContext::k_AsPoints, NULL, "object", transP, NULL);


	// Assign an array of normalized shading normals to Nn.
	RtNormal3 const  *Nn;
	ctx->GetBuiltinVar(RixShadingContext::k_Nn, &Nn);    

	// Assign an array of normalized view vectors to Vn.
	RtVector3 const  *Vn;
	ctx->GetBuiltinVar(RixShadingContext::k_Vn, &Vn);

	RtInt samples = *int_samples;
	RtFloat	maxDistance = *float_maxdist;
	RtFloat distanceScale = *float_distscale;
	RtColorRGB primaryColour = *rgb_primary;
	RtColorRGB secondaryColour =*rgb_secondary;
	RtConstString trace = *str_traceset;

	float ao_angle = 0.95f;
	float traceMaxDist = 10000.0f;
	float farClipPlane = 10000.0f;

	const float noiseScale = 10000.0f;
	const float noiseStrength = 0.0001f;


	// Get Nn and mpSize, used by RixApplyTraceBias()
	RtFloat const *biasR;
	RtFloat const *biasT;
	ctx->GetBuiltinVar(RixShadingContext::k_biasR, &biasR);
	ctx->GetBuiltinVar(RixShadingContext::k_biasT, &biasT);
	 
	RtFloat const  *PRadius;
	ctx->GetBuiltinVar(RixShadingContext::k_PRadius, &PRadius);
				
	RtRayGeometry *occrays = pool.AllocForPattern<RtRayGeometry>(ctx->numPts);
	RtHitPoint *occhits = pool.AllocForPattern<RtHitPoint>(ctx->numPts);

	RtInt rayNum = 0;

	RtInt autoBias = 0;
	RtFloat biasValue = 0.01f;
	getTraceBias(*ctx, autoBias, biasValue);

	// Init occlusion
//	for(int i = 0; i < ctx->numPts; i++)
//	{
//		result[i].r = 0.0f;
//		result[i].g = 0.0f;
//		result[i].b = 0.0f;
//		resultF[i] = 0.0f;
	//}
	
	//for(int j = 0; j < samples; j++)
	//{
		rayNum = 0;
		// Assign values to the output(s).
	
		// Init the array of RtRayGeometry structs
		// This is simpler than inside an integrator. We only need to seed a few
		// fields. InitTransmitOrigination() must be called on valid points
		// otherwise the renderer may hang
		for(int i = 0; i < ctx->numPts; i++)
		{	
			RtFloat3 randomSeed = RtFloat3(0.0f);// RtFloat3((i+j)*5,(i+j)*23,(i+j)*64);
			//RtFloat3 randomOffset = m_shd->Noise3(randomSeed);
			
			RtFloat3 bruit = RtFloat3(0.0f);
			RtFloat3 perlinNoise = m_shd->Noise3( (P[i]) * noiseScale );
			RtVector3 AO_dir = Nn[i] + (0.001f * perlinNoise);

			if( ao_angle != 0.0f)
			{
				RtFloat3 cellnoise = m_shd->CellNoise3( (AO_dir) * noiseScale);
				bruit = ao_angle * (1.0f - 2.0f * cellnoise);
				AO_dir += bruit;
			}

			AO_dir.Normalize();
			occrays[rayNum].direction = AO_dir;

			if (autoBias)
			{
				occrays[rayNum].origin = RixApplyTraceBias(P[i], Nn[i], occrays[rayNum].direction, biasR[i], biasT[i]);
			}
			else
			{
				occrays[rayNum].origin = P[i] + biasValue * occrays[rayNum].direction;
			}
			
			occrays[rayNum].maxDist = maxDistance;
			occrays[rayNum].raySpread = 1e-6f;
			occrays[rayNum].originRadius = PRadius[i];
			occrays[rayNum].InitTransmitOrigination(ctx,i);
			++rayNum;
		}
	
		if (rayNum != ctx->numPts)
		{
			m_msg->Error("[PxrOcclusion]  Number of traceable points doesn't match number of points !");
		}
		
		if(rayNum >0)
		{
			ctx->GetNearestHits(ctx->numPts, occrays, occhits);
			
			for(int i = 0; i < ctx->numPts; i++)
			{
				float dist = occhits[i].dist;
				float mixage = clamp( (dist/distanceScale), 0.0f, 1.0f );
				resultF[i] = mixage;
			}
		}
	
	//}
	
	for(int i = 0; i < ctx->numPts; i++)
	{
		// Average
		//result[i].r /= samples;
		//result[i].g /= samples;
		//result[i].b /= samples;
		//resultF[i] /= samples;
		
		// Invert results
		//result[i].r = 1.0f - result[i].r;
		//result[i].g = 1.0f - result[i].g;
		//result[i].b = 1.0f - result[i].b;
		//resultF[i] = 1.0f - resultF[i];
		
		result[i].r = mix(primaryColour.r, secondaryColour.r, resultF[i] );
		result[i].g = mix(primaryColour.g, secondaryColour.g, resultF[i] );
		result[i].b = mix(primaryColour.b, secondaryColour.b, resultF[i] );
	}
	
	return 0;
}

RIX_PATTERNCREATE
{
	return new PxrOcclusion();
}

RIX_PATTERNDESTROY
{
	delete((PxrOcclusion*)pattern);
}
